{
    "author": "Lukas Reiter", 
    "plugins": [
        8
    ], 
    "burp_professional_only": true, 
    "uuid": "c5b76994-90ff-4e0d-8419-434e8365cdeb", 
    "version": "v1.0", 
    "script": "def do_passive_scan(message_info, session):\r\n\t\"\"\"\r\n\tThe Scanner invokes this method for each base request / response that is\r\n\tpassively scanned. Note: Extensions should only analyze the HTTP messages\r\n\tprovided during passive scanning, and should not make any new HTTP\r\n\trequests of their own.\r\n\r\n\t:param request (IRequestResponse): The base HTTP request / response that\r\n\tshould be passively scanned.\r\n\t:param session (dict): The dictionary allows storing information accross\r\n\tmethod calls.\r\n\t:return A list of IScanIssue objects, or null if no issues are identified.\r\n\t\"\"\"\r\n\tprint(\"Passive Scan\")\r\n\treturn None\r\n\r\ndef do_active_scan(message_info, insertion_point, session):\r\n\t\"\"\"\r\n\tThe Scanner invokes this method for each insertion point that is actively\r\n\tscanned. Extensions may issue HTTP requests as required to carry out\r\n\tactive scanning, and should use the IScannerInsertionPoint object provided\r\n\tto build scan requests for particular payloads.\r\n\tNote:\r\n\tScan checks should submit raw non-encoded payloads to insertion points,\r\n\tand the insertion point has responsibility for performing any data\r\n\tencoding that is necessary given the nature and location of the insertion\r\n\tpoint.\r\n\r\n\t:param request(IRequestResponse): The base HTTP request / response that\r\n\tshould be actively scanned.\r\n\t:param insertion_point: An IScannerInsertionPoint object that can be\r\n\tqueried to obtain details of the insertion point being tested, and can be\r\n\tused to build scan requests for particular payloads.\r\n\t:param session (dict): The dictionary allows storing information accross\r\n\tmethod calls.\r\n\t:return A list of IScanIssue objects, or null if no issues are identified.\r\n\t\"\"\"\r\n\tprint(\"Active Scan\")\r\n\treturn None\r\n\r\ndef consolidate_duplicate_issues(existing_issue, new_issue):\r\n\t\"\"\"\r\n\tThe Scanner invokes this method when the custom Scanner check has\r\n\treported multiple issues for the same URL path. This can arise either\r\n\tbecause there are multiple distinct vulnerabilities, or because the same\r\n\t(or a similar) request has been scanned more than once. The custom check\r\n\tshould determine whether the issues are duplicates. In most cases, where\r\n\ta check uses distinct issue names or descriptions for distinct issues,\r\n\tthe consolidation process will simply be a matter of comparing these\r\n\tfeatures for the two issues.\r\n\r\n\t:param existing_issue: An issue that was previously reported by this\r\n\tScanner check.\r\n\t:param new_issue: An issue at the same URL path that has been newly\r\n\treported by this Scanner check.\r\n\t:return An indication of which issue(s) should be reported in the main\r\n\tScanner results. The method should return -1 to report the existing\r\n\tissue only, 0 to report both issues, and 1 to report the new issue only.\r\n\t\"\"\"\r\n\treturn -1\r\n", 
    "name": "Scan - Template Script to Implement a Scanner Check"
}